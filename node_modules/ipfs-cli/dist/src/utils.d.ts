export function getIpfs(argv: any): Promise<{
    isDaemon: boolean;
    ipfs: import("ipfs-core/src/components");
    cleanup: () => Promise<void>;
} | {
    isDaemon: boolean;
    ipfs: {
        add: (input: import("../../ipfs-core/node_modules/ipfs-core-types/src/files").ToEntry, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src/root").AddAllOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("../../ipfs-core/node_modules/ipfs-core-types/src/files").UnixFSEntry>;
        addAll: (source: import("../../ipfs-core/node_modules/ipfs-core-types/src/files").ImportSource, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src/root").AddAllOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => AsyncIterable<import("../../ipfs-core/node_modules/ipfs-core-types/src/files").UnixFSEntry>;
        bitswap: {
            wantlist: (options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<IPFS.CID[]>;
            wantlistForPeer: (peerId: string | IPFS.CID | Uint8Array | IPFS.PeerId, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<IPFS.CID[]>;
            stat: (options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bitswap/stat").BitswapStats>;
            unwant: (cid: IPFS.CID | IPFS.CID[], options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<void>;
        };
        block: {
            get: (cid: string | IPFS.CID | Uint8Array, options?: (import("ipfs-core/src/components/block/get").GetOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("../../ipfs-core/node_modules/ipfs-core-types/src/block-service").Block>;
            stat: (cid: IPFS.CID, options?: (import("ipfs-core/src/components/block/stat").StatOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/block/stat").Stat>;
            put: (data: Uint8Array | import("../../ipfs-core/node_modules/ipfs-core-types/src/block-service").Block, options?: (import("ipfs-core/src/components/block/put").PutOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("../../ipfs-core/node_modules/ipfs-core-types/src/block-service").Block>;
            rm: (cid: IPFS.CID | IPFS.CID[], options?: (import("ipfs-core/src/components/block/rm").RmOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/block/rm").RmResult>;
        };
        bootstrap: {
            add: (addr: IPFS.multiaddr, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            clear: (options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            rm: (addr: IPFS.multiaddr, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            reset: (options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            list: (options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
        };
        cat: (path: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src/root").CatOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => AsyncIterable<Uint8Array>;
        commands: (options?: {} | undefined) => Promise<any>;
        config: {
            getAll: import("ipfs-http-client/src/interface").APIWithExtraOptions<(options?: import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/config").IPFSConfig>, import("ipfs-http-client/src").HttpOptions>;
            get: import("ipfs-http-client/src/interface").APIWithExtraOptions<(key: string, options?: import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions | undefined) => Promise<import("../../ipfs-core/node_modules/ipfs-core-types/src/basic").ToJSON>, import("ipfs-http-client/src").HttpOptions>;
            set: import("ipfs-http-client/src/interface").APIWithExtraOptions<(key: string, value: import("../../ipfs-core/node_modules/ipfs-core-types/src/basic").ToJSON, options?: import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions | undefined) => Promise<void>, import("ipfs-http-client/src").HttpOptions>;
            replace: import("ipfs-http-client/src/interface").APIWithExtraOptions<(value: import("ipfs-core/src/components/config").IPFSConfig, options?: import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions | undefined) => Promise<void>, import("ipfs-http-client/src").HttpOptions>;
            profiles: {
                apply: (profile: any, options?: {} | undefined) => Promise<{
                    original: any;
                    updated: any;
                }>;
                list: (options?: {} | undefined) => Promise<any>;
            };
        };
        dag: {
            get: import("ipfs-http-client/src/interface").APIWithExtraOptions<(ipfsPath: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/dag/get").GetOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions) | undefined) => Promise<import("ipfs-core/src/components/dag/get").DagEntry>, import("ipfs-http-client/src").HttpOptions>;
            put: import("ipfs-http-client/src/interface").APIWithExtraOptions<(dagNode: any, options?: (import("ipfs-core/src/components/dag/put").WithCID & import("ipfs-core/src/components/dag/put").OtherPutOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions) | (import("ipfs-core/src/components/dag/put").WithCIDOptions & import("ipfs-core/src/components/dag/put").OtherPutOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions) | undefined) => Promise<IPFS.CID>, import("ipfs-http-client/src").HttpOptions>;
            resolve: import("ipfs-http-client/src/interface").APIWithExtraOptions<(ipfsPath: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/dag/resolve").ResolveOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions) | undefined) => Promise<import("ipfs-core/src/components/dag/resolve").ResolveResult>, import("ipfs-http-client/src").HttpOptions>;
        };
        dht: {
            get: (key: string | Uint8Array, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<Uint8Array>;
            put: (key: Uint8Array, value: Uint8Array, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").QueryEvent>;
            findProvs: (cid: IPFS.CID, options?: (import("ipfs-core/src/components/dht").FindProvsOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").PeerInfo>;
            findPeer: (peerId: IPFS.CID | IPFS.PeerId, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<{
                id: string;
                addrs: IPFS.multiaddr[];
            }>;
            provide: (cids: IPFS.CID | IPFS.CID[], options?: (import("ipfs-core/src/components/dht").ProvideOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").QueryEvent>;
            query: (peerId: string | IPFS.PeerId, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => AsyncIterable<{
                id: IPFS.CID;
                addrs: IPFS.multiaddr[];
            }>;
        };
        diag: {
            net: (options?: {} | undefined) => Promise<any>;
            sys: (options?: {} | undefined) => Promise<any>;
            cmds: (options?: {} | undefined) => Promise<any>;
        };
        dns: import("ipfs-http-client/src/interface").APIWithExtraOptions<(domain: string, options?: import("ipfs-core/src/components/dns").DNSOptions | undefined) => Promise<string>, import("ipfs-http-client/src").HttpOptions>;
        files: {
            chmod: (path: string, mode: import("../../ipfs-core/node_modules/ipfs-core-types/src/files").ToMode, options?: (import("ipfs-core/src/components/files/chmod").ChmodOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<void>;
            cp: (...args: [a1: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/files/cp").CpOptions & import("ipfs-http-client/src").HttpOptions) | undefined] | [a1: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, a2: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/files/cp").CpOptions & import("ipfs-http-client/src").HttpOptions) | undefined] | [a1: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, a2: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, a3: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/files/cp").CpOptions & import("ipfs-http-client/src").HttpOptions) | undefined]) => Promise<void>;
            flush: (path: string, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<IPFS.CID>;
            ls: (path: string, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/files/ls").UnixFSEntry>;
            mkdir: (path: string, options?: (import("ipfs-core/src/components/files/mkdir").MkdirOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<void>;
            mv: (...args: [a1: string, a2: string, options?: (import("ipfs-core/src/components/files/mv").MvOptions & import("ipfs-http-client/src").HttpOptions) | undefined] | [a1: string, a2: string, a3: string, options?: (import("ipfs-core/src/components/files/mv").MvOptions & import("ipfs-http-client/src").HttpOptions) | undefined]) => Promise<void>;
            read: (path: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/files/read").ReadOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => AsyncIterable<Uint8Array>;
            rm: (...args: [a1: string, options?: (import("ipfs-core/src/components/files/rm").RmOptions & import("ipfs-http-client/src").HttpOptions) | undefined] | [a1: string, a2: string, options?: (import("ipfs-core/src/components/files/rm").RmOptions & import("ipfs-http-client/src").HttpOptions) | undefined] | [a1: string, a2: string, a3: string, options?: (import("ipfs-core/src/components/files/rm").RmOptions & import("ipfs-http-client/src").HttpOptions) | undefined]) => Promise<void>;
            stat: (path: string, options?: (import("ipfs-core/src/components/files/stat").StatOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/files/stat").Stat>;
            touch: (path: string, options?: (import("ipfs-core/src/components/files/touch").TouchOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<void>;
            write: (path: string, input: string | Uint8Array | AsyncIterable<Uint8Array> | Blob, options?: (import("ipfs-core/src/components/files/write").WriteOptions & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<void>;
        };
        get: (path: import("../../ipfs-core/node_modules/ipfs-core-types/src/root").IPFSPath, options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src/root").GetOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => AsyncIterable<import("../../ipfs-core/node_modules/ipfs-core-types/src/files").IPFSEntry>;
        getEndpointConfig: () => {
            host: string;
            port: string;
            protocol: string;
            pathname: string;
            'api-path': string;
        };
        id: (options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/id").ID>;
        key: {
            gen: (name: any, options?: {} | undefined) => Promise<any>;
            list: (options?: {} | undefined) => Promise<any>;
            rename: (oldName: any, newName: any, options?: {} | undefined) => Promise<any>;
            rm: (name: any, options?: {} | undefined) => Promise<any>;
            import: (name: any, pem: any, password: any, options?: {} | undefined) => Promise<any>;
        };
        log: {
            tail: (options?: {} | undefined) => AsyncGenerator<any, void, undefined>;
            ls: (options?: {} | undefined) => Promise<any>;
            level: (subsystem: any, level: any, options?: {} | undefined) => Promise<any>;
        };
        ls: (path: any, options?: {} | undefined) => AsyncGenerator<{
            name: any;
            path: string;
            size: any;
            cid: IPFS.CID;
            type: string;
            depth: any;
        }, void, undefined>;
        mount: (options?: {} | undefined) => Promise<any>;
        name: {
            publish: (path: any, options?: {} | undefined) => Promise<any>;
            resolve: (path: any, options?: {} | undefined) => AsyncGenerator<any, void, unknown>;
            pubsub: {
                cancel: (name: any, options?: {} | undefined) => Promise<any>;
                state: (options?: {} | undefined) => Promise<any>;
                subs: (options?: {} | undefined) => Promise<any>;
            };
        };
        object: {
            data: (cid: any, options?: {} | undefined) => Promise<Uint8Array>;
            get: (cid: any, options?: {} | undefined) => Promise<any>;
            links: (cid: any, options?: {} | undefined) => Promise<any>;
            new: (options?: {} | undefined) => Promise<IPFS.CID>;
            patch: {
                addLink: (cid: any, dLink: any, options?: {} | undefined) => Promise<IPFS.CID>;
                appendData: (cid: any, data: any, options?: {} | undefined) => Promise<IPFS.CID>;
                rmLink: (cid: any, dLink: any, options?: {} | undefined) => Promise<IPFS.CID>;
                setData: (cid: any, data: any, options?: {} | undefined) => Promise<IPFS.CID>;
            };
            put: (obj: any, options?: {} | undefined) => Promise<IPFS.CID>;
            stat: (cid: any, options?: {} | undefined) => Promise<any>;
        };
        pin: {
            add: (path: any, options?: {} | undefined) => Promise<IPFS.CID | undefined>;
            addAll: (source: any, options?: {} | undefined) => AsyncGenerator<IPFS.CID, void, unknown>;
            ls: (options?: {} | undefined) => AsyncGenerator<{
                type: any;
                cid: IPFS.CID;
            }, void, unknown>;
            rm: (path: any, options?: {} | undefined) => Promise<any>;
            rmAll: (source: any, options?: {} | undefined) => AsyncGenerator<any, void, any>;
            remote: import("ipfs-http-client/src/pin/remote");
        };
        ping: (peerId: any, options?: {} | undefined) => AsyncGenerator<any, void, undefined>;
        pubsub: {
            ls: (options?: {} | undefined) => Promise<any>;
            peers: (topic: any, options?: {} | undefined) => Promise<any>;
            publish: (topic: any, data: any, options?: {} | undefined) => Promise<void>;
            subscribe: (topic: any, handler: any, options?: {} | undefined) => Promise<any>;
            unsubscribe: (topic: any, handler: any) => Promise<any>;
        };
        refs: {
            (args: any, options?: {} | undefined): AsyncGenerator<any, void, undefined>;
            local: (options?: {} | undefined) => AsyncGenerator<any, void, undefined>;
        };
        repo: {
            gc: (options?: {} | undefined) => AsyncGenerator<any, void, undefined>;
            stat: (options?: {} | undefined) => Promise<{
                numObjects: import("bignumber.js").default;
                repoSize: import("bignumber.js").default;
                repoPath: any;
                version: any;
                storageMax: import("bignumber.js").default;
            }>;
            version: (options?: {} | undefined) => Promise<any>;
        };
        resolve: (path: string, options?: (import("ipfs-core/src/components/resolve").ResolveSettings & import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<string>;
        stats: {
            bitswap: (options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bitswap/stat").BitswapStats>;
            bw: (options?: {} | undefined) => AsyncGenerator<any, void, undefined>;
            repo: (options?: {} | undefined) => Promise<{
                numObjects: import("bignumber.js").default;
                repoSize: import("bignumber.js").default;
                repoPath: any;
                version: any;
                storageMax: import("bignumber.js").default;
            }>;
        };
        stop: (options?: {} | undefined) => Promise<void>;
        shutdown: (options?: {} | undefined) => Promise<void>;
        swarm: {
            addrs: (options?: {} | undefined) => Promise<{
                id: string;
                addrs: any;
            }[]>;
            connect: (addrs: any, options?: {} | undefined) => Promise<any>;
            disconnect: (addrs: any, options?: {} | undefined) => Promise<any>;
            localAddrs: (options?: {} | undefined) => Promise<any>;
            peers: (options?: {} | undefined) => Promise<any>;
        };
        version: (options?: (import("../../ipfs-core/node_modules/ipfs-core-types/src").AbortOptions & import("ipfs-http-client/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/version").Version>;
    };
    cleanup: () => Promise<void>;
}>;
export function isDaemonOn(): boolean;
export function getRepoPath(): string;
export function disablePrinting(): void;
/**
 *
 * @param {string} msg
 * @param {boolean} [includeNewline=true]
 * @param {boolean} [isError=false]
 */
export function print(msg: string, includeNewline?: boolean | undefined, isError?: boolean | undefined): void;
export namespace print {
    function clearLine(): boolean;
    function cursorTo(pos: any): void;
    function write(data: string | Uint8Array): void;
    function error(msg: string, newline?: boolean | undefined): void;
    const isTTY: boolean;
    const columns: number;
}
export function createProgressBar(totalBytes: any, output: any): any;
export function rightpad(val: any, n: any): string;
export const ipfsPathHelp: string;
export function asBoolean(value: any): any;
export function asOctal(value: any): number;
export function asMtimeFromSeconds(secs: any, nsecs: any): {
    secs: any;
} | undefined;
export function coerceMtime(value: any): any;
export function coerceMtimeNsecs(value: any): any;
/**
 * Strip control characters from a string
 *
 * @param {string} str - a string to strip control characters from
 * @returns {string}
 */
export function stripControlCharacters(str: string): string;
/**
 * Escape control characters in a string
 *
 * @param {string} str - a string to escape control characters in
 * @returns {string}
 */
export function escapeControlCharacters(str: string): string;
/**
 * Removes control characters from all key/values and stringifies
 * CID properties
 *
 * @param {object} obj - all keys/values in this object will be have control characters stripped
 * @param {import('cids').BaseNameOrCode} cidBase - any encountered CIDs will be stringified using this base
 * @returns {object}
 */
export function makeEntriesPrintable(obj: object, cidBase?: import('cids').BaseNameOrCode): object;
import IPFS_1 = require("ipfs-core/src");
//# sourceMappingURL=utils.d.ts.map