export = Network;
declare class Network {
    /**
     * @param {Options} options
     */
    static start({ peerId, repo, print, options }: Options): Promise<Network>;
    /**
     * @param {Network} network
     */
    static stop(network: Network): Promise<void>;
    /**
     * @param {PeerId} peerId
     * @param {LibP2P} libp2p
     * @param {BitSwap} bitswap
     */
    constructor(peerId: PeerId, libp2p: LibP2P, bitswap: BitSwap);
    peerId: import("peer-id");
    libp2p: import("libp2p/src/");
    bitswap: import("ipfs-core-types/src/bitswap").Bitswap;
}
declare namespace Network {
    export { Online, Options, IPFSConfig, IPFSOptions, Repo, Print, LibP2P, BitSwap, PeerId, AbortOptions };
}
type Options = {
    peerId: PeerId;
    repo: Repo;
    print: Print;
    options: IPFSOptions;
};
type PeerId = import("peer-id");
type LibP2P = import("libp2p/src/");
type BitSwap = import("ipfs-core-types/src/bitswap").Bitswap;
type Online = {
    libp2p: LibP2P;
    bitswap: BitSwap;
};
type IPFSConfig = {
    Addresses: import("./config").AddressConfig;
    Profiles?: string | undefined;
    Bootstrap?: string[] | undefined;
    Discovery: import("./config").DiscoveryConfig;
    Datastore?: import("./config").DatastoreConfig | undefined;
    Identity?: import("./config").IdentityConfig | undefined;
    Keychain?: import("./config").KeychainConfig | undefined;
    Pubsub?: import("./config").PubsubConfig | undefined;
    Swarm?: import("./config").SwarmConfig | undefined;
    Routing?: import("./config").RoutingConfig | undefined;
};
type IPFSOptions = import("./storage").StorageOptions & import(".").IPFSOptions;
type Repo = import("ipfs-core-types/src/repo").Repo<import("./config").IPFSConfig>;
type Print = (...args: any[]) => void;
type AbortOptions = import("ipfs-core-types").AbortOptions;
//# sourceMappingURL=network.d.ts.map