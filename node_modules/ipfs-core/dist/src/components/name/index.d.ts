export = NameAPI;
declare class NameAPI {
    /**
     * @param {Object} config
     * @param {IPNS} config.ipns
     * @param {PeerId} config.peerId
     * @param {Options} config.options
     * @param {DagReader} config.dagReader
     * @param {IsOnline} config.isOnline
     * @param {Keychain} config.keychain
     * @param {DNS} config.dns
     */
    constructor({ dns, ipns, dagReader, peerId, isOnline, keychain, options }: {
        ipns: IPNS;
        peerId: PeerId;
        options: Options;
        dagReader: DagReader;
        isOnline: IsOnline;
        keychain: Keychain;
        dns: DNS;
    });
    publish: (value: string, options?: createPublishAPI.PublishOptions | undefined) => Promise<createPublishAPI.PublishResult>;
    resolve: (name: string, options?: (createResolveAPI.Options & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<string>;
    pubsub: PubSubAPI;
}
declare namespace NameAPI {
    export { Options, ExperimentalOptions, PubSubOptions, ResolveOptions, IPNS, PeerId, DagReader, Keychain, IsOnline, DNS, AbortOptions };
}
import createPublishAPI = require("./publish");
import createResolveAPI = require("./resolve");
import PubSubAPI = require("./pubsub");
type IPNS = import("../ipns");
type PeerId = import("peer-id");
type Options = createResolveAPI.ResolveOptions & ExperimentalOptions;
type DagReader = {
    get: (ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: (import("../dag/get").GetOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<import("../dag/get").DagEntry>;
    resolve: (ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: (import("../dag/resolve").ResolveOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<import("../dag/resolve").ResolveResult>;
    tree: (ipfsPath: import("cids"), options?: (import("../dag/tree").TreeOptions & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<string>;
};
type IsOnline = () => boolean;
type Keychain = import("libp2p/src/keychain");
type DNS = (domain: string, options?: import("../dns").DNSOptions | undefined) => Promise<string>;
type ExperimentalOptions = {
    EXPERIMENTAL?: import("./pubsub/utils").PubSubRoutingOptions | undefined;
};
type PubSubOptions = {
    /**
     * - Enable pub-sub on IPNS. (Default: `false`)
     */
    ipnsPubsub?: boolean | undefined;
};
type ResolveOptions = {
    offline?: boolean | undefined;
};
type AbortOptions = import("ipfs-core-types").AbortOptions;
//# sourceMappingURL=index.d.ts.map