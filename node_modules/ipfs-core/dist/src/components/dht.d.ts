declare function _exports({ network, repo }: {
    network: import('.').NetworkService;
    repo: import('.').Repo;
}): {
    get: (key: string | Uint8Array, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<Uint8Array>;
    put: (key: Uint8Array, value: Uint8Array, options?: import("ipfs-core-types").AbortOptions | undefined) => AsyncIterable<QueryEvent>;
    findProvs: (cid: CID, options?: (FindProvsOptions & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<PeerInfo>;
    findPeer: (peerId: CID | PeerId, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<{
        id: string;
        addrs: Multiaddr[];
    }>;
    provide: (cids: CID | CID[], options?: (ProvideOptions & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<QueryEvent>;
    query: (peerId: string | PeerId, options?: import("ipfs-core-types").AbortOptions | undefined) => AsyncIterable<{
        id: CID;
        addrs: Multiaddr[];
    }>;
};
export = _exports;
export type QueryEvent = {
    id: PeerId;
    type: number;
    extra: string;
    responses: PeerInfo[];
};
export type ProvideOptions = {
    /**
     * - Provide not only the given object but also all objects linked from it.
     */
    recursive?: boolean | undefined;
};
export type FindProvsOptions = {
    /**
     * - maximum number of providers to find
     */
    numProviders?: number | undefined;
    maxNumProviders?: number | undefined;
};
export type PeerInfo = {
    id: PeerId;
    addrs: Multiaddr[];
};
export type Multiaddr = import("multiaddr");
export type AbortOptions = import("ipfs-core-types").AbortOptions;
import CID = require("cids");
import PeerId = require("peer-id");
//# sourceMappingURL=dht.d.ts.map