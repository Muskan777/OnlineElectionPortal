export = IPFS;
declare class IPFS {
    /**
     * @param {Options} options
     */
    static create(options?: Options): Promise<IPFS>;
    /**
     * @param {Object} config
     * @param {Print} config.print
     * @param {StorageAPI} config.storage
     * @param {Options} config.options
     */
    constructor({ print, storage, options }: {
        print: Print;
        storage: StorageAPI;
        options: Options;
    });
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: import("ipfs-core-types/src/root").IPFSPath): Promise<void>;
        start(): void;
        stop(): void;
    };
    name: NameAPI;
    ipld: import("ipfs-core-types/src/ipld").IPLD<any>;
    ipns: IPNSAPI;
    pin: PinAPI;
    resolve: (path: string, opts?: createResolveAPI.ResolveOptions | undefined) => Promise<string>;
    block: BlockAPI;
    refs: ((ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: (createRefsAPI.RefsOptions & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<createRefsAPI.RefResult>) & {
        local: (options?: import("ipfs-core-types").AbortOptions | undefined) => AsyncIterable<{
            ref: string;
        }>;
    };
    start: () => Promise<void>;
    stop: () => Promise<void>;
    dht: {
        get: (key: string | Uint8Array, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<Uint8Array>;
        put: (key: Uint8Array, value: Uint8Array, options?: import("ipfs-core-types").AbortOptions | undefined) => AsyncIterable<createDHTAPI.QueryEvent>;
        findProvs: (cid: import("cids"), options?: (createDHTAPI.FindProvsOptions & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<createDHTAPI.PeerInfo>;
        findPeer: (peerId: import("cids") | import("peer-id"), options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<{
            id: string;
            addrs: import("multiaddr")[];
        }>;
        provide: (cids: import("cids") | import("cids")[], options?: (createDHTAPI.ProvideOptions & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<createDHTAPI.QueryEvent>;
        query: (peerId: string | import("peer-id"), options?: import("ipfs-core-types").AbortOptions | undefined) => AsyncIterable<{
            id: import("cids");
            addrs: import("multiaddr")[];
        }>;
    };
    pubsub: {
        subscribe: (topic: string, handler: (message: createPubSubAPI.Message) => void, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<void>;
        unsubscribe: (topic: string, handler?: ((message: createPubSubAPI.Message) => void) | undefined, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<void>;
        publish: (topic: string, data: Uint8Array, options: import("ipfs-core-types").AbortOptions) => Promise<void>;
        ls: (options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<string[]>;
        peers: (topic: string, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<string[]>;
    };
    dns: (domain: string, options?: createDNSAPI.DNSOptions | undefined) => Promise<string>;
    isOnline: () => boolean;
    id: (_options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<createIDAPI.ID>;
    version: (options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<createVersionAPI.Version>;
    bitswap: BitswapAPI;
    bootstrap: BootstrapAPI;
    config: {
        getAll: (options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<createConfigAPI.IPFSConfig>;
        get: (key: string, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<import("ipfs-core-types/src/basic").ToJSON>;
        set: (key: string, value: import("ipfs-core-types/src/basic").ToJSON, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<void>;
        replace: (value: createConfigAPI.IPFSConfig, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<void>;
        profiles: {
            apply: (profileName: string, options?: any) => Promise<{
                original: createConfigAPI.IPFSConfig;
                updated: createConfigAPI.IPFSConfig;
            }>;
            list: (_options: any) => Promise<{
                name: string;
                description: string;
            }[]>;
        };
    };
    ping: (peerId: import("peer-id"), options?: createPingAPI.PingOptions | undefined) => AsyncIterable<createPingAPI.Packet>;
    add: (entry: import("ipfs-core-types/src/files").ToEntry, options?: import("ipfs-core-types/src/root").AddAllOptions | undefined) => Promise<import("ipfs-core-types/src/files").UnixFSEntry>;
    addAll: (source: import("ipfs-core-types/src/files").ImportSource, options?: import("ipfs-core-types/src/root").AddAllOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/files").UnixFSEntry>;
    cat: (ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: import("ipfs-core-types/src/root").CatOptions | undefined) => AsyncIterable<Uint8Array>;
    get: (ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: import("ipfs-core-types/src/root").GetOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/files").IPFSEntry>;
    ls: (ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: import("ipfs-core-types/src/root").ListOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/files").IPFSEntry>;
    dag: DagAPI;
    files: createFilesAPI.MFS;
    key: KeyAPI;
    object: ObjectAPI;
    repo: RepoAPI;
    stats: StatsAPI;
    swarm: SwarmAPI;
    /**
     * `IPFS.create` will do the initialization. Keep this around for backwards
     * compatibility.
     *
     * @deprecated
     */
    init(): Promise<void>;
}
declare namespace IPFS {
    export { Options, IPFSOptions, ExperimentalOptions, StorageOptions, PreloadOptions, IPLDOptions, LibP2POptions, RelayOptions, InitOptions, StorageAPI, NetworkOptions, NetworkService, Repo, Print, Keychain, IPFSConfig, PeerId, LibP2P, PinManager, BlockService, BitSwap, IPLD, GCLock, Preload, MFSPreload, IPNS, Pin, Block, DagReader, Dag, Files, IsOnline, Resolve, Refs, DNS, Name, AbortOptions, CID, Multiaddr, IPLDBlock };
}
import NameAPI = require("./name");
import IPNSAPI = require("./ipns");
import PinAPI = require("./pin");
import createResolveAPI = require("./resolve");
import BlockAPI = require("./block");
import createRefsAPI = require("./refs");
import createDHTAPI = require("./dht");
import createPubSubAPI = require("./pubsub");
import createDNSAPI = require("./dns");
import createIDAPI = require("./id");
import createVersionAPI = require("./version");
import BitswapAPI = require("./bitswap");
import BootstrapAPI = require("./bootstrap");
import createConfigAPI = require("./config");
import createPingAPI = require("./ping");
import DagAPI = require("./dag");
import createFilesAPI = require("./files");
import KeyAPI = require("./key");
import ObjectAPI = require("./object");
import RepoAPI = require("./repo");
import StatsAPI = require("./stats");
import SwarmAPI = require("./swarm");
type Options = Storage.StorageOptions & IPFSOptions;
type Print = (...args: any[]) => void;
type StorageAPI = Storage;
/**
 * Options argument can be used to specify advanced configuration.
 */
type IPFSOptions = {
    /**
     * - Initialization options
     * the IPFS node.
     * Note that *initializing* a repo is different from creating an instance of
     * [`ipfs.Repo`](https://github.com/ipfs/js-ipfs-repo). The IPFS constructor
     * sets many special properties when initializing a repo, so you should usually
     * not try and call `repoInstance.init()` yourself.
     */
    init?: Storage.InitOptions | undefined;
    /**
     * - If `false`, do not automatically
     * start the IPFS node. Instead, you’ll need to manually call
     * [`node.start()`](https://github.com/ipfs/js-ipfs/blob/master/packages/ipfs/docs/MODULE.md#nodestart)
     * yourself.
     */
    start?: boolean | undefined;
    /**
     * - A passphrase to encrypt/decrypt your keys.
     */
    pass?: string | undefined;
    /**
     * - Prevents all logging output from the
     * IPFS node. (Default: `false`)
     */
    silent?: boolean | undefined;
    /**
     * - Configure circuit relay (see the [circuit relay tutorial]
     * (https://github.com/ipfs/js-ipfs/tree/master/examples/circuit-relaying)
     * to learn more).
     */
    relay?: RelayOptions | undefined;
    /**
     * - Run ipfs node offline. The node does
     * not connect to the rest of the network but provides a local API.
     */
    offline?: boolean | undefined;
    /**
     * - Configure remote preload nodes.
     * The remote will preload content added on this node, and also attempt to
     * preload objects requested by this node.
     */
    preload?: createPreloadAPI.Options | undefined;
    /**
     * - Enable and configure
     * experimental features.
     */
    EXPERIMENTAL?: ExperimentalOptions | undefined;
    /**
     * - Modify the default IPFS node config. This
     * object will be *merged* with the default config; it will not replace it.
     * (Default: [`config-nodejs.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/config-nodejs.js)
     * in Node.js, [`config-browser.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/config-browser.js)
     * in browsers)
     */
    config?: createConfigAPI.IPFSConfig | undefined;
    /**
     * - Modify the default IPLD config. This object
     * will be *merged* with the default config; it will not replace it. Check IPLD
     * [docs](https://github.com/ipld/js-ipld#ipld-constructor) for more information
     * on the available options. (Default: [`ipld.js`]
     * (https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/ipld-nodejs.js) in Node.js, [`ipld-browser.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/ipld-browser.js)
     * (https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/ipld.js)
     * in browsers)
     */
    ipld?: import("ipfs-core-types/src/ipld").Options | undefined;
    /**
     * - The libp2p option allows you to build
     * your libp2p node by configuration, or via a bundle function. If you are
     * looking to just modify the below options, using the object format is the
     * quickest way to get the default features of libp2p. If you need to create a
     * more customized libp2p node, such as with custom transports or peer/content
     * routers that need some of the ipfs data on startup, a custom bundle is a
     * great way to achieve this.
     * - You can see the bundle in action in the [custom libp2p example](https://github.com/ipfs/js-ipfs/tree/master/examples/custom-libp2p).
     * - Please see [libp2p/docs/CONFIGURATION.md](https://github.com/libp2p/js-libp2p/blob/master/doc/CONFIGURATION.md)
     * for the list of options libp2p supports.
     * - Default: [`libp2p-nodejs.js`](../src/core/runtime/libp2p-nodejs.js)
     * in Node.js, [`libp2p-browser.js`](../src/core/runtime/libp2p-browser.js) in
     * browsers.
     */
    libp2p?: Function | import("./libp2p").Options | undefined;
    repoOwner?: boolean | undefined;
};
type ExperimentalOptions = {
    /**
     * - Enable pub-sub on IPNS. (Default: `false`)
     */
    ipnsPubsub?: boolean | undefined;
    /**
     * - Enable directory sharding. Directories that have many child objects will be represented by multiple DAG nodes instead of just one. It can improve lookup performance when a directory has several thousand files or more. (Default: `false`)
     */
    sharding?: boolean | undefined;
};
type StorageOptions = {
    /**
     * - The file path at which to store the
     * IPFS node’s data. Alternatively, you can set up a customized storage system
     * by providing an Repo implementation. (In browser default is 'ipfs').
     */
    repo?: string | import("ipfs-core-types/src/repo").Repo<createConfigAPI.IPFSConfig> | undefined;
    /**
     * - js-ipfs comes bundled with a tool
     * that automatically migrates your IPFS repository when a new version is
     * available.
     */
    repoAutoMigrate?: boolean | undefined;
    repoOwner?: boolean | undefined;
    ipld?: import("ipfs-core-types/src/ipld").Options | undefined;
};
type PreloadOptions = {
    /**
     * - Whether to preload anything
     */
    enabled?: boolean | undefined;
    /**
     * - How many CIDs to cache
     */
    cache?: number | undefined;
    /**
     * - Which preload servers to use.
     * **NOTE:** nodes specified here should also be added to your node's bootstrap address list at `config.Boostrap`.
     */
    addresses?: string[] | undefined;
};
type IPLDOptions = import("ipfs-core-types/src/ipld").Options;
type LibP2POptions = import("libp2p/src/").Libp2pOptions & import("libp2p/src/").constructorOptions;
type RelayOptions = {
    /**
     * - Enable circuit relay dialer and listener. (Default: `true`)
     */
    enabled?: boolean | undefined;
    hop?: {
        /**
         * - Make this node a relay (other nodes can connect *through* it). (Default: `false`)
         */
        enabled?: boolean | undefined;
        /**
         * - Make this an *active* relay node. Active relay nodes will attempt to dial a destin
         */
        active?: boolean | undefined;
    } | undefined;
};
type InitOptions = {
    /**
     * - Whether to remove built-in assets,
     * like the instructional tour and empty mutable file system, from the repo.
     */
    emptyRepo?: boolean | undefined;
    /**
     * - The type of key to use.
     */
    algorithm?: "Ed25519" | "RSA" | "secp256k1" | undefined;
    /**
     * - Number of bits to use in the generated key
     * pair (rsa only).
     */
    bits?: number | undefined;
    /**
     * - A pre-generated private key to use.
     * **NOTE: This overrides `bits`.**
     */
    privateKey?: string | import("peer-id") | undefined;
    /**
     * - A passphrase to encrypt keys. You should
     * generally use the top-level `pass` option instead of the `init.pass`
     * option (this one will take its value from the top-level option if not set).
     */
    pass?: string | undefined;
    /**
     * - Apply profile settings to config.
     */
    profiles?: string[] | undefined;
    /**
     * - Set to `false` to disallow
     * initialization if the repo does not already exist.
     */
    allowNew?: boolean | undefined;
};
type NetworkOptions = {
    peerId: import("peer-id");
    repo: import("ipfs-core-types/src/repo").Repo<createConfigAPI.IPFSConfig>;
    print: Print;
    options: Options;
};
type NetworkService = Service<Network.Options, Network>;
type Repo = import("ipfs-core-types/src/repo").Repo<createConfigAPI.IPFSConfig>;
type Keychain = import("libp2p/src/keychain");
type IPFSConfig = {
    Addresses: createConfigAPI.AddressConfig;
    Profiles?: string | undefined;
    Bootstrap?: string[] | undefined;
    Discovery: createConfigAPI.DiscoveryConfig;
    Datastore?: createConfigAPI.DatastoreConfig | undefined;
    Identity?: createConfigAPI.IdentityConfig | undefined;
    Keychain?: createConfigAPI.KeychainConfig | undefined;
    Pubsub?: createConfigAPI.PubsubConfig | undefined;
    Swarm?: createConfigAPI.SwarmConfig | undefined;
    Routing?: createConfigAPI.RoutingConfig | undefined;
};
type PeerId = import("peer-id");
type LibP2P = import("libp2p/src/");
type PinManager = PinManagerAPI;
type BlockService = import("ipfs-core-types/src/block-service").BlockService;
type BitSwap = import("ipfs-core-types/src/bitswap").Bitswap;
type IPLD = import("ipfs-core-types/src/ipld").IPLD<any>;
type GCLock = {
    readLock: () => Promise<createGCLockAPI.Lock>;
    writeLock: () => Promise<createGCLockAPI.Lock>;
};
type Preload = ((() => void) & {
    start: () => void;
    stop: () => void;
}) | {
    (path: import("ipfs-core-types/src/root").IPFSPath): Promise<void>;
    start(): void;
    stop(): void;
};
type MFSPreload = {
    start(): Promise<void>;
    stop(): void;
};
type IPNS = IPNSAPI;
type Pin = PinAPI;
type Block = BlockAPI;
type DagReader = {
    get: (ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: (import("./dag/get").GetOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<import("./dag/get").DagEntry>;
    resolve: (ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: (import("./dag/resolve").ResolveOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<import("./dag/resolve").ResolveResult>;
    tree: (ipfsPath: import("cids"), options?: (import("./dag/tree").TreeOptions & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<string>;
};
type Dag = DagAPI;
type Files = {
    stat: (path: string, options?: (import("./files/stat").StatOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<import("./files/stat").Stat>;
    chmod: (path: string, mode: import("ipfs-core-types/src/files").ToMode, options?: (import("./files/chmod").ChmodOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<void>;
    cp: (...args: [import("ipfs-core-types/src/root").IPFSPath, (import("./files/cp").CpOptions | undefined)?] | [import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, (import("./files/cp").CpOptions | undefined)?] | [import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, (import("./files/cp").CpOptions | undefined)?] | [import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, (import("./files/cp").CpOptions | undefined)?] | [import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, (import("./files/cp").CpOptions | undefined)?] | [import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, (import("./files/cp").CpOptions | undefined)?] | [import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, (import("./files/cp").CpOptions | undefined)?] | [import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, import("ipfs-core-types/src/root").IPFSPath, (import("./files/cp").CpOptions | undefined)?]) => Promise<void>;
    flush: (path: string, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<import("cids")>;
    mkdir: (path: string, options?: (import("./files/mkdir").MkdirOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<void>;
    mv: (...args: [string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?]) => Promise<void>;
    rm: (...args: [string, (import("./files/rm").RmOptions | undefined)?] | [string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?]) => Promise<void>;
    touch: (path: string, options?: (import("./files/touch").TouchOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<void>;
    write: (path: string, content: string | Uint8Array | AsyncIterable<Uint8Array> | Blob, options?: (import("./files/write").WriteOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<void>;
    read: (path: import("ipfs-core-types/src/root").IPFSPath, options?: (import("./files/read").ReadOptions & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    ls: (path: string, options?: import("ipfs-core-types").AbortOptions | undefined) => AsyncIterable<import("./files/ls").UnixFSEntry>;
};
type IsOnline = () => boolean;
type Resolve = (path: string, opts?: createResolveAPI.ResolveOptions | undefined) => Promise<string>;
type Refs = (ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: (createRefsAPI.RefsOptions & import("ipfs-core-types").AbortOptions) | undefined) => AsyncIterable<createRefsAPI.RefResult>;
type DNS = (domain: string, options?: createDNSAPI.DNSOptions | undefined) => Promise<string>;
type Name = NameAPI;
type AbortOptions = import("ipfs-core-types").AbortOptions;
type CID = import("cids");
type Multiaddr = import("multiaddr");
type IPLDBlock = import("ipfs-core-types/src/block-service").Block;
import Storage = require("./storage");
import createPreloadAPI = require("../preload");
import Network = require("./network");
import Service = require("../utils/service");
import PinManagerAPI = require("./pin/pin-manager");
import createGCLockAPI = require("./gc-lock");
//# sourceMappingURL=index.d.ts.map