export = Storage;
declare class Storage {
    /**
     *
     * @param {Options} options
     */
    static start(options: Options): Promise<Storage>;
    /**
     * @private
     * @param {PeerId} peerId
     * @param {Keychain} keychain
     * @param {Repo} repo
     * @param {Print} print
     * @param {boolean} isNew
     */
    private constructor();
    print: import(".").Print;
    peerId: PeerId;
    keychain: import("libp2p/src/keychain");
    repo: import("ipfs-core-types/src/repo").Repo<configService.IPFSConfig>;
    isNew: boolean;
}
declare namespace Storage {
    export { Options, StorageOptions, RepoOptions, ConfigureOptions, InitOptions, IPLDOptions, Print, IPFSConfig, Repo, KeyType, Keychain };
}
import PeerId = require("peer-id");
import configService = require("./config");
type Options = StorageOptions & RepoOptions & InitOptions;
type StorageOptions = {
    /**
     * - The file path at which to store the
     * IPFS nodeâ€™s data. Alternatively, you can set up a customized storage system
     * by providing an Repo implementation. (In browser default is 'ipfs').
     */
    repo?: string | import("ipfs-core-types/src/repo").Repo<configService.IPFSConfig> | undefined;
    /**
     * - js-ipfs comes bundled with a tool
     * that automatically migrates your IPFS repository when a new version is
     * available.
     */
    repoAutoMigrate?: boolean | undefined;
    repoOwner?: boolean | undefined;
    ipld?: import("ipfs-core-types/src/ipld").Options | undefined;
};
type RepoOptions = {
    print: Print;
    config?: configService.IPFSConfig | undefined;
    silent?: boolean | undefined;
};
type ConfigureOptions = {
    config?: configService.IPFSConfig | undefined;
    profiles?: string[] | undefined;
    pass?: string | undefined;
};
/**
 * - On Frist run js-ipfs will initalize a repo
 * which can be customized through this settings.
 */
type InitOptions = {
    /**
     * - Whether to remove built-in assets,
     * like the instructional tour and empty mutable file system, from the repo.
     */
    emptyRepo?: boolean | undefined;
    /**
     * - The type of key to use.
     */
    algorithm?: "Ed25519" | "RSA" | "secp256k1" | undefined;
    /**
     * - Number of bits to use in the generated key
     * pair (rsa only).
     */
    bits?: number | undefined;
    /**
     * - A pre-generated private key to use.
     * **NOTE: This overrides `bits`.**
     */
    privateKey?: string | PeerId | undefined;
    /**
     * - A passphrase to encrypt keys. You should
     * generally use the top-level `pass` option instead of the `init.pass`
     * option (this one will take its value from the top-level option if not set).
     */
    pass?: string | undefined;
    /**
     * - Apply profile settings to config.
     */
    profiles?: string[] | undefined;
    /**
     * - Set to `false` to disallow
     * initialization if the repo does not already exist.
     */
    allowNew?: boolean | undefined;
};
type IPLDOptions = import("ipfs-core-types/src/ipld").Options;
type Print = (...args: any[]) => void;
type IPFSConfig = {
    Addresses: configService.AddressConfig;
    Profiles?: string | undefined;
    Bootstrap?: string[] | undefined;
    Discovery: configService.DiscoveryConfig;
    Datastore?: configService.DatastoreConfig | undefined;
    Identity?: configService.IdentityConfig | undefined;
    Keychain?: configService.KeychainConfig | undefined;
    Pubsub?: configService.PubsubConfig | undefined;
    Swarm?: configService.SwarmConfig | undefined;
    Routing?: configService.RoutingConfig | undefined;
};
type Repo = import("ipfs-core-types/src/repo").Repo<configService.IPFSConfig>;
type KeyType = "Ed25519" | "RSA" | "secp256k1";
type Keychain = import("libp2p/src/keychain");
//# sourceMappingURL=storage.d.ts.map