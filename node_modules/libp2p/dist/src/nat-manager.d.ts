export = NatManager;
declare class NatManager {
    /**
     * @class
     * @param {object} options
     * @param {PeerId} options.peerId - The peer ID of the current node
     * @param {TransportManager} options.transportManager - A transport manager
     * @param {AddressManager} options.addressManager - An address manager
     * @param {boolean} options.enabled - Whether to enable the NAT manager
     * @param {string} [options.externalIp] - Pass a value to use instead of auto-detection
     * @param {string} [options.description] - A string value to use for the port mapping description on the gateway
     * @param {number} [options.ttl] - How long UPnP port mappings should last for in seconds (minimum 1200)
     * @param {boolean} [options.keepAlive] - Whether to automatically refresh UPnP port mappings when their TTL is reached
     * @param {string} [options.gateway] - Pass a value to use instead of auto-detection
     * @param {object} [options.pmp] - PMP options
     * @param {boolean} [options.pmp.enabled] - Whether to enable PMP as well as UPnP
     */
    constructor({ peerId, addressManager, transportManager, ...options }: {
        peerId: PeerId;
        transportManager: TransportManager;
        addressManager: AddressManager;
        enabled: boolean;
        externalIp: string | undefined;
        description: string | undefined;
        ttl: number | undefined;
        keepAlive: boolean | undefined;
        gateway: string | undefined;
        pmp: {
            enabled?: boolean | undefined;
        } | undefined;
    });
    _peerId: import("peer-id");
    _addressManager: import("./address-manager");
    _transportManager: import("./transport-manager");
    _enabled: boolean;
    _externalIp: string | undefined;
    _options: {
        description: string;
        ttl: number;
        autoUpdate: boolean;
        gateway: string | undefined;
        enablePMP: boolean;
    };
    /**
     * Starts the NAT manager
     */
    start(): void;
    _start(): Promise<void>;
    _getClient(): {
        /**
         * @param  {...any} args
         * @returns {Promise<void>}
         */
        map: (...args: any[]) => Promise<void>;
        /**
         * @param  {...any} args
         * @returns {Promise<void>}
         */
        destroy: (...args: any[]) => Promise<void>;
        /**
         * @param  {...any} args
         * @returns {Promise<string>}
         */
        externalIp: (...args: any[]) => Promise<string>;
    };
    _client: {
        /**
         * @param  {...any} args
         * @returns {Promise<void>}
         */
        map: (...args: any[]) => Promise<void>;
        /**
         * @param  {...any} args
         * @returns {Promise<void>}
         */
        destroy: (...args: any[]) => Promise<void>;
        /**
         * @param  {...any} args
         * @returns {Promise<string>}
         */
        externalIp: (...args: any[]) => Promise<string>;
    } | null | undefined;
    /**
     * Stops the NAT manager
     *
     * @async
     */
    stop(): Promise<void>;
}
declare namespace NatManager {
    export { PeerId, TransportManager, AddressManager };
}
type PeerId = import("peer-id");
type TransportManager = import("./transport-manager");
type AddressManager = import("./address-manager");
//# sourceMappingURL=nat-manager.d.ts.map