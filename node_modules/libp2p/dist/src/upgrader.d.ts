export = Upgrader;
/**
 * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto
 * @typedef {import('multiaddr')} Multiaddr
 */
/**
 * @typedef CryptoResult
 * @property {MultiaddrConnection} conn A duplex iterable
 * @property {PeerId} remotePeer
 * @property {string} protocol
 */
declare class Upgrader {
    /**
     * @param {object} options
     * @param {PeerId} options.localPeer
     * @param {import('./metrics')} [options.metrics]
     * @param {Map<string, Crypto>} [options.cryptos]
     * @param {Map<string, MuxerFactory>} [options.muxers]
     * @param {(Connection) => void} options.onConnection - Called when a connection is upgraded
     * @param {(Connection) => void} options.onConnectionEnd
     */
    constructor({ localPeer, metrics, cryptos, muxers, onConnectionEnd, onConnection }: {
        localPeer: import("peer-id");
        metrics?: import("./metrics") | undefined;
        cryptos?: Map<string, import("libp2p-interfaces/src/crypto/types").Crypto> | undefined;
        muxers?: Map<string, import("libp2p-interfaces/src/stream-muxer/types").MuxerFactory> | undefined;
        onConnection: (Connection: any) => void;
        onConnectionEnd: (Connection: any) => void;
    });
    localPeer: import("peer-id");
    metrics: import("./metrics") | undefined;
    cryptos: Map<string, import("libp2p-interfaces/src/crypto/types").Crypto>;
    muxers: Map<string, import("libp2p-interfaces/src/stream-muxer/types").MuxerFactory>;
    protector: any;
    protocols: Map<any, any>;
    onConnection: (Connection: any) => void;
    onConnectionEnd: (Connection: any) => void;
    /**
     * Upgrades an inbound connection
     *
     * @async
     * @param {MultiaddrConnection} maConn
     * @returns {Promise<Connection>}
     */
    upgradeInbound(maConn: MultiaddrConnection): Promise<import("libp2p-interfaces/src/connection/connection")>;
    /**
     * Upgrades an outbound connection
     *
     * @async
     * @param {MultiaddrConnection} maConn
     * @returns {Promise<Connection>}
     */
    upgradeOutbound(maConn: MultiaddrConnection): Promise<import("libp2p-interfaces/src/connection/connection")>;
    /**
     * A convenience method for generating a new `Connection`
     *
     * @private
     * @param {object} options
     * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated
     * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']
     * @param {MultiaddrConnection} options.maConn - The transport layer connection
     * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection
     * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing
     * @param {PeerId} options.remotePeer - The peer the connection is with
     * @returns {Connection}
     */
    private _createConnection;
    /**
     * Routes incoming streams to the correct handler
     *
     * @private
     * @param {object} options
     * @param {Connection} options.connection - The connection the stream belongs to
     * @param {MuxedStream} options.stream
     * @param {string} options.protocol
     */
    private _onStream;
    /**
     * Attempts to encrypt the incoming `connection` with the provided `cryptos`.
     *
     * @private
     * @async
     * @param {PeerId} localPeer - The initiators PeerId
     * @param {*} connection
     * @param {Map<string, Crypto>} cryptos
     * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used
     */
    private _encryptInbound;
    /**
     * Attempts to encrypt the given `connection` with the provided `cryptos`.
     * The first `Crypto` module to succeed will be used
     *
     * @private
     * @async
     * @param {PeerId} localPeer - The initiators PeerId
     * @param {*} connection
     * @param {PeerId} remotePeerId
     * @param {Map<string, Crypto>} cryptos
     * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used
     */
    private _encryptOutbound;
    /**
     * Selects one of the given muxers via multistream-select. That
     * muxer will be used for all future streams on the connection.
     *
     * @private
     * @async
     * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex
     * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with
     * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection
     */
    private _multiplexOutbound;
    /**
     * Registers support for one of the given muxers via multistream-select. The
     * selected muxer will be used for all future streams on the connection.
     *
     * @private
     * @async
     * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex
     * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with
     * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection
     */
    private _multiplexInbound;
}
declare namespace Upgrader {
    export { MultiaddrConnection, MuxerFactory, Muxer, MuxedStream, Crypto, Multiaddr, CryptoResult };
}
type MultiaddrConnection = {
    sink: import("libp2p-interfaces/src/stream-muxer/types").Sink;
    source: () => AsyncIterable<Uint8Array>;
    close: (err?: Error | undefined) => Promise<void>;
    conn: unknown;
    remoteAddr: import("multiaddr");
    localAddr?: import("multiaddr") | undefined;
    timeline: import("libp2p-interfaces/src/transport/types").MultiaddrConnectionTimeline;
};
type MuxerFactory = import("libp2p-interfaces/src/stream-muxer/types").MuxerFactory;
type Muxer = import("libp2p-interfaces/src/stream-muxer/types").Muxer;
type MuxedStream = import("libp2p-interfaces/src/stream-muxer/types").MuxedStream;
type Crypto = import("libp2p-interfaces/src/crypto/types").Crypto;
type Multiaddr = import("multiaddr");
type CryptoResult = {
    /**
     * A duplex iterable
     */
    conn: MultiaddrConnection;
    remotePeer: import("peer-id");
    protocol: string;
};
//# sourceMappingURL=upgrader.d.ts.map